<!DOCTYPE html>
<html>
<head>
  <title>reactr</title>
  <meta charset="utf-8" />
  <link rel="stylesheet" href="css/tachyons.min.css">
  <link rel="stylesheet" href="css/style.css">
  <script src="libs/jquery.js"></script>
  <script src="libs/lodash.js"></script>
  <script src="libs/react.js"></script>
  <script src="libs/react-dom.js"></script>
  <script src="libs/react-dom-server.min.js"></script>
  <script src="libs/babel.min.js"></script>
  <script src="libs/polyfill.min.js"></script>
  <script src="libs/browser.min.js"></script>
  <script src="libs/ace.js"></script>
  <script src="libs/showdown.min.js"></script>
</head><body>

<div id="root"></div>

<script id="data" type="text/babel">

window['data'] = {
  name: "Nicolas Martinet",
  contact: [
    {name: "email",  val: "nicolas.martinet@gmail.com"},
    {name: "telephone", val: "123-456-7890"},
    {name: "website", val: "nmartinet.github.io"}
  ],
  skills: {
    title: "Skills",
    content: [
      'excel, vba',
      'html, js, css',
      'c#, ruby, python',
      'sql',
      'French and English',
    ]
  },
  education: {
    title: "Education",
    content: [
      {date: '2007-2011', title: 'John Molson School of Business, Concordia University, Montreal, Quebec', desc: 'Bachelor of Commerce, Major in Accountancy'
      },
      {date: '2004-2006', title: 'Collège International Marie de France', desc: 'French Baccalaureate in economics, specialization in mathematics (DEC Equivalent)'
      }
    ]
  },
  profExp: {
    title: "Professional Experience",
    content: [
      {date: '2014-2015', title: 'Ubisoft - IT-Dev Services', desc: `
Programer Analyst
- As part of IT-Dev, develop and maintain internal applications for the various internal services (hr/logistics/fincances/etc).
- Analyse and understand internal customers business requirements
- Work alongside other anylsts to design, code and test modiifcations to internal software
      `},
      {date: '2011-2014', 
       title: 'Ubisoft - Projects Cost Control', 
       desc: `
Financial Analyst
- Design, implement and maintain:
  - Reports and finaacial planning tools used by the projects to prepare and follow their budgets.
  - Local datawarehouses to better answer local needs. Improved responsiveness and quality of available data
  - Toolchain used by the analyst team to setup, update, maintain and analyse budgets.
- Follow and controt budgets of multiple game projects
  - Act as support and main point of contact for the projects producer
  - Setup initial bugets with the producer
  - Analyse and maintain budgets and forecasts
- Follow and analyse budgets for the headoffice.
  - Analyse and control costs for the headoffice
  - Prepare reports on the state of the budgets. 
- Ensure proper financial information is shared between the projects productions team, local management and the headoffice.
- Calculate the yearly SRED credits for the projects.
       `},
      {date: '2006-2009', 
       title: 'Caisse Centrale Desjardins - Credit and integrated risk management sector' , 
       desc: 
`Internship
  - Testing new reports being developed
  - Preparing daily, monthly and quarterly reports
  - Performing quarterly reconciliations at month and quarter end. 
  - Automating some reports and jobs through excel templates and VBA
  - Performed some translation from French to English
  - Various other jobs to alleviate work load for the department and to perform essential services during other employee’s vacations.` 
}]
},
};

window['dataSettings'] = {
  dataset: 'data', 
  reactr:{
    editor: 'DataEdit'
  }
}

window['componentsSettings'] = {
  dataset: 'components',
  functions: `function() {
    var self = {};
    self.registerComponent =  function(component, name){
      var presets = { presets: ['es2015', 'react'] };
      var compCode = "window['" + name + "'] = React.createClass(" + component + ")";
      compCode = Babel.transform(compCode, presets).code;

      eval(compCode)
    }

    self.registerComponents = function(components){
      _.forEach(components, self.registerComponent);
    };

    return self;
  }`, 
  hooks: {
    'onInit': 'registerComponents',
  },
  reactr:{
    editor: 'ComponentEditor',
  }
}


window['components'] = {
  ReactrRoot: `{
    init: function(){
      let self = this;
      let {datasets} = this.props;
      let state = {funcs: {}};

      _.forEach(datasets, function(ds, name){
        state.funcs[name] = ds.q;
        state[name] = ds.data;
        ds.q.registerCallback('onChange', function(data){
          var tmpState = {};
          tmpState[name] = data;
          self.setState(tmpState);
        })
      });

      return state;
    },
    getInitialState: function(){
      return this.init();
    },
    render: function(){
      let {datasets} = this.state;
      let {ctrls} = this.props;
      let self = this;

      let dsEditors = _.map(this.props.datasets, function(ds){
        let {name, editor} = ds.q.getInfo();

        return (
          <div label={name} key={name}>
            {React.createElement(window[editor], {data: self.state[name], q: self.state.funcs[name], path: [], root:  self })}
          </div>
        );
      });

      return (
        <div className="cf">

          <div className="fl w-50">
            <CV data={self.state.data} />
          </div>

          <div className="fl w-50 pa3">
            <h1 className="f1 tracked tr fw1 bb bw1 b--silver fw1">reactr</h1>
            <ReactrControls  ctrls={ctrls} data={self.state.data} />
            <Tabs selected="0">
              {dsEditors}
            </Tabs>
          </div>
        </div>
      )
    }
  }`,
  Scratch: `{
    render: function(){
      return (
        <div>
          scratch
          <ToggleMenu>
            <ul>
              <li>1</li>
              <li>1</li>
              <li>1</li>
              <li>1</li>
            </ul>
          </ToggleMenu>
        </div>
      )
    }
  }`,
  ToggleMenu: `{
    toggleVisibility: function(){
      var visible = this.state.visible;

      if (visible) {
        window.removeEventListener('click', this.onClick);
      } else {
        window.addEventListener('click', this.onClick);
      };

      this.setState({visible: !visible}) 
    },
    onClick: function(evnt){ 
      //http://stackoverflow.com/questions/32553158/detect-click-outside-react-component
      var thisNode = ReactDOM.findDOMNode(this)
      if( !thisNode.contains(evnt.target))
        this.toggleVisibility();
    },
    getInitialState: () => ( {visible: false} ),
    render: function(){
      let cnames = cn(
        'relative',
        (this.state.visible ? '' : 'no-display')
      );

      return (
        <div className="">
          <a onClick={this.toggleVisibility}> 
            \u270E
          </a>
          <div className={cn(cnames, 'z-1')}on>
            {this.props.children}
          </div>
        </div>
      )
    }
  }`,
  ComponentEditor: `{
    updateCurrentComponent: function(){
      let {selected, buffer} = this.state;
      let val = this.editor.getValue();
      this.props.q.registerComponent(val, selected );
      this.props.root.forceUpdate();
      this.props.q.updateValue([selected], val);
    },
    newComponent: function(name){
      this.props.q.addKey([], name, "")
      return "";
    },
    setEditOptions: function(option){
      this.editor.setOptions(option)
    },
    onComponentChange: function(key){
      if(this.props.data[this.state.selected] != this.editor.getValue()) {
        var buffer = this.state.buffer;
        buffer[this.state.selected] = this.editor.getValue();
        this.setState({buffer: buffer});
      };

      this.setState({selected: key});
      this.updateEditorValue(key);
    },
    updateEditorValue: function(key){
      var value;
      if(_.has(this.state.buffer, key)){
        value =this.state.buffer[key]; 
      } else {
        value = this.props.data[key]
      }
       this.editor.setValue(value);
    },
    componentDidMount: function(){
      this.editor = ace.edit('editor');
      this.editor.setTheme("ace/theme/clouds");
      this.editor.getSession().setMode("ace/mode/javascript");
      this.editor.$blockScrolling = Infinity;
      this.editor.setShowPrintMargin(false);
      this.setEditOptions({
        minLines: 25,
        maxLines: 50,
        fontSize: "14pt",
      })
      this.editor.setValue(this.props.data[this.state.selected]);
    },
    getInitialState: function(){
      return {
        selected: _.keys(this.props.data)[0],
        buffer: {},
      }
    },
    render: function(){
      var self = this;
      let {data} = self.props;
      let buffer = self.state.buffer;

      return (
        <div className="dt w-100">
          <div className="dtc w-25">
            <ComponentList 
              components={data} 
              selected={self.state.selected}
              buffer={buffer} 
              onClick={this.onComponentChange} 
              newComponent={this.newComponent}/>
          </div>
          
          <div className="dtc w-75 pl3 pt3">
            <ComponentEditorFileControls 
              updateComponent={self.updateCurrentComponent}  
              setOption={self.setEditOptions}/>
            
            <div id="editor">
            </div>
          
          </div>
        </div>
      )
    },
  }`,
  ComponentEditorFileControls: `{
    onApply: function(){
      this.props.updateComponent();
    },
    setFontSize: function(size){
      this.props.setOption({fontSize: size});
    },
    render: function(){
      let self = this;
      let itmClass = "f6 f5-ns b db pa2 link dim dark-gray ba b--black-20";

      let fontSizes = _.map(_.range(12, 18), (n) => n+"pt" );

      let listCn = "dib mb1 mr3"

      return (
        <ul className="list ma0 pl0 pb2">
          <li className={listCn}>
            <a href="#" className={itmClass} onClick={self.onApply}>
              Apply
            </a>
          </li>

          <li className={listCn}>
            <div className="f6 b">
              font size
            </div>
            <div>
              <Dropdown 
                options={fontSizes}
                value={fontSizes[0]}
                onChange={self.setFontSize}/>
            </div>
          </li>

        </ul>
      )
    },
  }`,
  ComponentList: `{
    onClick: function(key, evnt){
      evnt.preventDefault();
      this.props.onClick(key);
    },
    newComponent: function(name){
      this.props.newComponent(name)
      return "";
    },
    render: function(){
      var self = this;
      let {components, buffer} = self.props;

      var compList = _.map(components, function(comp, key){
        let modIndic = _.has(buffer, key) ? '\u2022' : "";
        let cNames = cn(
          "ph3 pv3 bb b--light-silver",
          (key == self.props.selected) ? 'b' : ''
        );
        return (
          <li className={cNames} key={key} onClick={self.onClick.bind(self, key)}>{key}{modIndic}</li>
        )
      })

      return (
        <div>
          <TextInputButton onClick={this.newComponent} placeholder="new component" buttonValue="add"/>
          <ul className="list pl0 ml0 center mw6 ba b--light-silver br2">
            {compList}
          </ul>
        </div>
        
      );
    }
  }`,
  TextInputButton: `{
    onChange: function(evnt){
      this.setState({value: evnt.target.value})
    },
    onClick: function(evnt){
      this.setState({value: this.props.onClick(this.state.value)});
    },
    getInitialState: function(){
      return {value: this.props.value || ""};
    },
    render: function(){
      return (
        <div>
          <input className="inpt" 
                     type="text" 
                     value={this.state.value} 
                     onChange={this.onChange}
                     placeholder={this.props.placeholder}/>
          <button className="btn" onClick={this.onClick}>
            {this.props.buttonValue || "ok"}
          </button>
        </div>
      )
    }
  }`,
  ReactrControls: `{
    onSave: function(e){
      this.props.ctrls.saveToFile();
    },
    onSaveStatic: function(e){
      this.props.ctrls.saveStaticDoc();
    },
    pData: function(){
      console.log(this.props.data)
    },
    render: function(){
      let btnClass="btn fr ml2";
      return (
        <div className="cf">
          <button className={btnClass} onClick={this.onSave} >
            Save
          </button>
          <button className={btnClass} onClick={this.onSaveStatic}>
            Save static doc
          </button>
          <button className={btnClass} onClick={this.pData}>
            debug data
          </button>
        </div>
      )
    }
  }`,
  Tabs: `{
    getInitialState: function(){
      return {
        selected: this.props.selected || 0
      };
    },
    onClick: function(indx, evnt){
      evnt.preventDefault();
      this.setState({selected: indx})

    },
    render: function(){
      var self = this;

      var tabList = _.map(self.props.children, function(child, index){
        var  cNames = "link dim black f1 dib mr5";
        if (index == self.state.selected)
          cNames += " bb bw2 b--silver "

        return (
          <a className={cNames} key={index} href="#" onClick={self.onClick.bind(self, index)}>
            {child.props.label}
          </a>
        )
      })
      var content = self.props.children[self.state.selected];

      return (
        <div className="nowrap overflow-x-auto">
          <div className="bb bw1 b--silver mb2">
            {tabList}
          </div>
          <div className="pa3 pt1">
            {content}
          </div>
          
        </div>
      )
    }
  }`,
  DataEdit: `{
    render: function(){
      var self = this;
      let {data, q, path} = self.props;

      var Editor = React.createElement(window[q.getType(path) + "Editor"], {data: data, q: q, path: path });
      
      return (
        <div>
          {Editor}
        </div>
      )
    }
  }`,
  ObjectEditor: `{
    modKey: function(path, newVal, evnt){
      this.props.q.modKey(path, newVal);
      return newVal
    }, 
    addKey: function(path, newVal, evnt){
      this.props.q.addKey(path, newVal);
      return "";
    },
    deleteKey: function(path, evnt){
      if (window.confirm("Delete key?")) {
        this.props.q.delKey(path);
      };
      
    },
    changeKeyType: function(path, newType, evnt){
      if (window.confirm("Change type? value will be deleted")){
        this.props.q.changeType(path, newType)
      };
    },
    getOptsMenu: function(path){
      let self = this;
      let {q} = self.props;

      let dType = q.getType(path);
      let types = q.getTypes();

      let opts = [
        (<a onClick={self.deleteKey.bind(self, path)}>Delete</a>),
        (<div>
          Data type: <Dropdown options={_.keys(types)} value={dType} onChange={self.changeKeyType.bind(self, path)} />
         </div>
        ),
      ];

      let optsUI = _.map(opts, (opt, i) => {
        return (
          <li key={i}>
            {opt}
          </li>
        )
      })

      return (
        <div className="ba b--silver bg-white pa2 ma0">
          <h3 className="mt0">Properties</h3>
          <ul className="list pl0">
            {optsUI}
          </ul>
        </div>
      );
    },
    render: function(){
      var self = this;
      let {data, q, path} = self.props;


      var keyVal = _.map(data, function(val, key){
        var _path = path.concat(key)
        let optsMenu = self.getOptsMenu(_path);

        return (
          <div key={key} className="cf">
            <div className="cf w-100">
              <div className="fl w-25">
                <TextInput val={key} 
                           placeholder={key} 
                           onSave={self.modKey}
                           ctrls={optsMenu}
                           path={_path} />        
              </div>
              <div className="fr w-75">
                <DataEdit data={val} q={q} path={_path} />
              </div>
            </div>
          </div>
        );
      });

      return (
        <div className="w-100">
          {keyVal}
          <div className="w-25">
            <TextInput val="" placeholder="new key" onSave={this.addKey} path={path}/>
          </div>
        </div>
      );
    },
  }`,
  TextInput: `{
    onChange: function(e){
      this.setState({val: e.target.value});
      if(e.target.value === this.props.data){
        this.setState({mod: false});
      } else {
        this.setState({mod: true});
      }
    },
    onSave: function(e){
      let newVal = this.props.onSave(this.props.path, this.state.val);
      this.setState({val: newVal, mod:false});
    },
    onMouseOver: function(e){
      this.setState({hover: true});
    },
    onMouseOut: function(e){
      this.setState({hover: false});
    },
    onFocus: function(e){
      this.setState({focused: true});
    },
    onBlur: function(e){
      this.setState({focused: false});
    },
    getInitialState: function(){
      return {
        val: this.props.val || "",
        mod: false,
        hover: false,
        focused: false,
      };
    },
    render: function(){
      var saveCtrls;
      if (this.state.mod && !(this.state.val === "")) {
        saveCtrls = (
          <a className="fl" onClick={this.onSave}>
            \u2713
          </a>
        )
      };
      
      let {hover, focused} = this.state;

      let propsBtn = cn(
        "fl dib absolute f8",
        (hover || focused ? '' : 'no-display')
      );

      let ctrls;
      if (this.props.ctrls) {
        ctrls = (
          <div className="fl">
            <ToggleMenu>
              {this.props.ctrls}
            </ToggleMenu>
          </div>
        ) 
      };

      return(
        <div className="cf mr3 relative pr3">
          <div className="w-100 fr dib">
            <input className="inpt w-100 tr" 
                   type="text" 
                   value={this.state.val} 
                   onChange={this.onChange}
                   onMouseOver={this.mouseOver}
                   onMouseOut={this.mouseOut}
                   onFocus={this.onFocus}
                   onBlur={this.onBlur}
                   placeholder={this.props.placeholder}/>
          </div>
          <div className="fl cf absolute f8">
            {ctrls}
            {saveCtrls}
          </div> 
        </div>
      )
    },
  }`,
  ArrayEditor: `{
    addArray: function(path, evnt){
      this.props.q.addArray(path);
    },
    deleteEntry: function(path, evnt){
      if (window.confirm("Delete value?")) {
        this.props.q.delKey(path);
      };
    },
    changeEntryType: function(path, newType, evnt){
      if (window.confirm("Change type? value will be deleted")){
        this.props.q.changeType(path, newType)
      };
    },
    moveEntry: function(path, newPos, evnt){
      this.props.q.moveEntry(path, newPos);
      this.setState({data: this.props.data});
      console.log(this.state)
    },
    getInitialState: function(){
      return {data: this.props.data};
    },
    render: function(){
      var self = this;
      let {data} = self.state
      let {q, path} = self.props;

      let opts = [
        (<a onClick={self.addArray.bind(self, path)}>Add entry</a>),
      ];

      let optsUI = _.map(opts, (opt, i) => {
        return (
          <li key={i}>
            {opt}
          </li>
        )
      });

      let propsButton = (
        <div className="fl">
          <ToggleMenu>
            <div className="ba b--silver bg-white pa2 ma0">
              <h3 className="mt0">Properties</h3>
              <ul className="list pl0">
                {optsUI}
              </ul>
            </div>
          </ToggleMenu>
        </div>
      )

      var getRowClass = function(index){
        if(index%2==0){
          return {
            row: "bg-black-10",
            num: "black-10"
          }
        }else{
          return {
            row: "bg-black-20",
            num: "black-10"
          }
        }
      }


      var itmList = _.map(data, function(val, index){
        var _path = path.concat(index);
        let {row, num} = getRowClass(index);

        let dType = q.getType(_path);
        let types = q.getTypes();
        
        let opts = [
          (<a onClick={self.deleteEntry.bind(self, _path)}>Delete</a>),
          (<div>
            Data type: <Dropdown options={_.keys(types)} value={dType} onChange={self.changeEntryType.bind(self, _path)} />
           </div>
          ),
          (<a onClick={self.moveEntry.bind(self, _path, (index-1))}>move up</a>),
          (<a onClick={self.moveEntry.bind(self, _path, (index+1))}>move down</a>),
        ];

        let optsUI = _.map(opts, (opt, i) => {
          return (
            <li key={i}>
              {opt}
            </li>
          )
        });

        let propsButton = (
          <div className="fl">
            <ToggleMenu>
              <div className="ba b--silver bg-white pa2 ma0">
                <h3 className="mt0">Properties</h3>
                <ul className="list pl0">
                  {optsUI}
                </ul>
              </div>
            </ToggleMenu>
          </div>
        )

        return (
          <div className={"cf w-100 relative "  + row} key={index}>

              <div className={"fl absolute w-auto f1 fw1 b ma1 " + num}>
                {index}
              </div>

              <div className="cf mr3 relative pr3">
                <div className="w-100 fr dib pl3">
                  <div className="w-100">
                    <DataEdit data={val} q={q} path={_path} />
                  </div>
                </div>

              <div className="fl cf absolute">
                {propsButton}
              </div> 
            </div>
          </div>
        )
      });

      return (
        <div className="cf mr3 relative pr3">
          <div className="w-100 fr dib pl3">
            <div className="ma1 ba bw1 b--silver w-100">
              {itmList}
            </div>
          </div>
          <div className="fl cf absolute">
            {propsButton}
          </div> 
        </div>
      )

    },
  }`,
  ValueEditor:  `{
    onChange: function(e){
      this.setState({val: e.target.value})
      this.props.q.updateValue(this.props.path, e.target.value)
    },
    getInitialState: function(){
      return {
        val: this.props.data || ""
      }
    },
    componentWillReceiveProps: function(props) {
      this.setState({val: props.data})
    },
    render: function(){
      var types = _.keys(this.props.q.getTypes());
      return (
        <div className="cf w-100">
          <div className="fl w-100">
            <input className="w-100 inpt" type="text" value={this.state.val} onChange={this.onChange} />
          </div>
        </div>
      )
    }
  }`,
  Dropdown: `{
    onChange: function(e){
      this.setState({value: e.target.value});
      this.props.onChange(e.target.value);
    },
    getInitialState: function(){
      return {
        value: this.props.value || null
      }
    },
    render: function(){
      var options = _.map(this.props.options, function(o, i){
        return (
          <option key={i} value={o}>{o}</option>
        )
      });

      return (
        <select className="inpt" onChange={this.onChange} value={this.state.value}>
          {options}
        </select>
      )
    },
  }`,
  CV: `{
    render: function(){
      let {data} = this.props;
      let mdConverter = new showdown.Converter();

      return (
        <div className="mw9 center pa3 ph5-ns">
          <CVHeader name={data.name}/>
          <ContactList contactInfo={data.contact} />
          <div className="pa4">
              <CVSection title={data.skills.title}>
                <VList elems={data.skills.content} />
              </CVSection> 
              <CVSection title={data.education.title}>
                <ChronoList elems={data.education.content} />
              </CVSection>
              <CVSection title={data.profExp.title} >
                <ChronoList elems={data.profExp.content} mdConverter={mdConverter}/>
              </CVSection>
          </div>
        </div>
      )
    },
  }`,
  CVHeader: `{
    render: function() {
      let {name} = this.props;
      return (
        <div className="bb bw1 mb3 b--light-silver" >
          <h1 className="f1 fw1 tracked tr mb0">{name}</h1>
        </div>
      );
    }
  }`,
  ContactList: `{
    render: function(){  
      
      let contact = _(this.props.contactInfo)
        .map( (info) => info.val )
        .reduce( (info, accum) => info + " // " + accum )
      
      return (
        <div className="fr">
          {contact}
        </div>
      )
    }
  }`,
  ContactBox: `{
    render: function() {
      let {contactInfo} = this.props;

      var boxContent = contactInfo.map(function(info){
        return (
          <li key={info.name} className="cf f5 pb3">
            <div className="fl">{info.name}</div>
            <div className="fr">{info.val}</div>
          </li>  
        );
      })

      return (
        <div className="w-25 ba bw1 b--light-silver fr pa3 dib">
          <h2 className="f3 mt0 tc">Contact Information</h2>
          <ul className="list pa0 ma0">
            {boxContent}
          </ul>
        </div>
      )

    }
  }`,
  CVSection: `{
    render: function(){
      return (
        <div className="fl mb5 w-100">
          <div className="dt mb3">
            <div className="dtc" style={{whiteSpace: "nowrap"}}>
              <h2 className="tl f3 fw5 mb2 mt0 fw1 tracked w-100"
                  >
                {this.props.title}
              </h2>
            </div>
            <div className="dtc w-100 v-mid pl2">
              <div className="bb w-100 b--light-silver"></div>
            </div>
          </div>
        
          {this.props.children}
        </div>
      )
    }
  }`,
  VList: `{
    render: function(){
      let listElems = _.map(this.props.elems, function(elem, i){
        return <li key={i} className="mb2">{elem}</li>
      })
      return (
        <ul className="pa0 ma0 pb2 mb2 pl4">
          {listElems}
        </ul>
      )
    }
  }`,
  ChronoList: `{
    render: function(){
      let self = this;
      let {elems} = this.props;

      
      
      if (self.props.mdConverter) {
        elems = _.map(elems, function(elem){
          elem.desc = self.props.mdConverter.makeHtml(elem.desc);
          return elem;
        })
      }; 

      let listElems = _.map(elems, function(elem, i){
        return (
          <li key={i} className="cf w-100 mb4">
            <div className="fl w-100-l w-20  b pr2 pb1">{elem.date}</div>
            <div className="fl w-100-l w-20 i pr4 pb1">{elem.title}</div>
            <div className="fl w-100-l w-60" dangerouslySetInnerHTML={ {__html: elem.desc}}></div>
          </li>
        )
      })

      return (
        <ul className="cf w-100 list pa0 mb0 pl4 mt0">
          {listElems}
        </ul>
      )
    }
  }`,
};

window['config'] = {
  elem:         'root',
  docRoot:      'CV',
  title:        'reactr',
  stylesheets:  ["css/tachyons.min.css",  
                 "css/style.css", 
                ],
  scripts:      [ "libs/jquery.js",
                  "libs/lodash.js",
                  "libs/react.js",
                  "libs/react-dom.js",
                  "libs/react-dom-server.min.js",
                  "libs/babel.min.js",
                  "libs/polyfill.min.js",
                  "libs/browser.min.js",
                  "libs/ace.js",
                  "libs/showdown.min.js",
                ],
  datasets:     ['dataSettings', 
                 'componentsSettings',
                 ],
}

</script>


<script id="reactr" type="text/babel">
  var cn = function(){
    return _.chain(arguments)
            .flattenDeep()
            .map(function(d){
              if(typeof(d) == 'object')
                return _.map(d, function(v, k){
                  return v ? k : '';
                })
              return d;
            })
            .flattenDeep()
            .reduce(function(d, a){
              return d + " " + a;
            })
            .value()
  }

  var ils = function(){

    return arguments
  }

  var Container = function(settings){
    var data;
    var name;
    var editor;
    var functions;
    var callbacks = {
      'onInit':   [],
      'onChange': [],
    };

    var types = {
      'Object': {},
      'Array': [],
      'Value': '',
    };


    var registerCallback = function(evnt, cb){
      if(!_.has(callbacks, evnt)) callbacks[evnt] = [];
      callbacks[evnt].push(cb);    
    };

    var trigger = function(evnt, arg){
      var _arg = arg || data;
      if(_.has(callbacks, evnt))
        _.forEach(callbacks[evnt], function(cb){
          cb(_arg);
        })
    };

    var doOn = function(path, cb){
      var _doOn = function(data, path, cb){
        if(path.length == 0) return cb(data);
        var _path = path.slice();
        var key = _path.shift();
        data[key] = _doOn(data[key], _path, cb);

        return data
      }
      data = _doOn(data, path, cb);
      trigger('onChange', data)
    };

    var readOn = function(path){
      var _readOn = function(data, path){
        if(path.length == 0) return data;
        var _path = path.slice();
        var key = _path.shift();
        return _readOn(data[key], _path); 
      };

      return _readOn(data, path);
    };

    var getType = function(path){
      var _getType = function(v){
        if ((typeof(v) === 'object') && !Array.isArray(v)) return 'Object';
        if (Array.isArray(v)) return 'Array';
        return 'Value';
      }

      return _getType(readOn(path))
    };

    var changeType = function(path, newType){
      var newValue = types[newType];
      doOn(path, function(d){
        return newValue;
      })
    };

    var updateValue = function(path, value){
      var value = value;
      doOn(path, function(d){
        return value;
      });
    };

    var addKey = function(path, key, newValue){
      var value = newValue || types['Object'];
      var key = key
      doOn(path, function(d){
        let newObj = _.clone(d);
        newObj[key] = value
        return newObj;
      })
    };

    var modKey = function(path, key){
      var path = path;
      var oldKey = path.pop();
      var newkey = key;
      doOn(path, function(d){
        d[newkey] = d[oldKey];
        delete d[oldKey];
        return d;
      });
    };

    var delKey = function(path){
      var path = path;
      var key = path.pop();
      doOn(path, function(d){
        delete d[key];
        return d;
      })
    };

    var addArray = function(path){
      doOn(path, function(d){
        d.push("")
        return d;
      })
    };

    var moveEntry = function(path, newPos){
      var arrayPath = path;
      var curPos = path.pop();
      var newPos = newPos;



      doOn(arrayPath, function(d){
        let arr = d;
        while(curPos < 0) {
          curPos += d.length;
        }
          
        while(newPos < 0) {
          newPos += d.length;
        }
        d.splice(newPos, 0, d.splice(curPos, 1)[0])
        

        return d;
      });
    }

    var getTypes = function(){
      return types
    };

    var getInfo = function(){
      return {
        name: name,
        editor: editor,
      }
    };

    var getData = function(){
      return data;
    }
   
  
    var init = function(settings){
      data      = window[settings.dataset];
      name      = settings.dataset;
      editor    = settings.reactr.editor;
      if(settings.functions){
        var presets = { presets: ['es2015', 'react'] };
        var compCode = "functions = " + settings.functions + "()";
        compCode = Babel.transform(compCode, presets).code;

        eval(compCode)
      };        

      functions = _.merge(functions, {
        getInfo: getInfo,
        getData: getData,
        doOn: doOn,
        readOn: readOn,
        updateValue: updateValue,
        registerCallback: registerCallback,
        getType: getType,
        getTypes: getTypes,
        addKey: addKey,
        modKey: modKey,
        delKey: delKey,
        addArray: addArray,
        moveEntry: moveEntry,
        changeType: changeType,
      })

      if( _.has(settings, 'hooks')){
        _.forEach(settings.hooks, function(cb, h){
          functions.registerCallback(h, functions[cb])
        });
      }


      trigger('onInit')
    };

    init(settings);

    return {
      data: data,
      q: functions,
    }
  };

  var Reactr = function(){
    var self        = this;
    var config;
    var datasets        = {};
    var ctrls           = {};

    var pPrint = function(c){
      var getType = function(v){
        if ((typeof(v) === 'object') && !Array.isArray(v)) return 'Object';
        if (Array.isArray(v)) return 'Array';
        return 'Value';
      }
      let toTypeString = {
        'Object': function(o){
          let self = this;
          let cnt = _(o)
                      .map(function(v, k){
                        return `"${k}":  ${self[getType(v)](v)}`
                      })
                      .reduce((a, b) => `${a}, \n ${b}`)
          return `{${cnt}} `
        },
        'Array': function(o){
          let self = this;
          let cnt = _(o)
                      .map(function(v){
                        return `${self[getType(v)](v)}`
                      })
                      .reduce((a, b) => `${a}, \n ${b}`)
          return `[${cnt}]`
        },
        'Value': function(o){
          return `\`${o}\``
        }
      };

      return toTypeString[getType(c)](c);
    }

    var promptForSave = function(content){
      var el = document.createElement('a');
      el.setAttribute('href', 
                      'data:text/plain;charset=utf-8,' 
                      + encodeURIComponent(content));
      
      el.setAttribute('download', 'index.html');
      el.style.display = 'none';

      document.body.appendChild(el);
      el.click();
      document.body.removeChild(el);
    };

    var getReactrCode = function(){

      return $('html').find('#reactr').html();
    }

    var generateFile = function(content){
      //defaults
      let {
        title       = 'reactr',
        meta        = `<meta charset="utf-8" />`,
        stylesheets = [],
        scripts     = [],
        datasets    = [], 
      } = content;

      let reactrCode = `<script id="reactr" type="text/babel">` + getReactrCode() + "</" + "script>";

      let cssImports = _(stylesheets)
                          .map((ss) => `<link rel="stylesheet" href="${ss}">`)
                          .reduce((x, a) => `${x} \n        ${a}`);

      //split closing tag - browser would interpret it as the closing tag of the 
      //current scirpt instead of a template
      let scriptImports = _(scripts)
                            .map((sf) => `<script src="${sf}">` + "</" + "script>")
                            .reduce((x, a) => `${x} \n        ${a}`);


      let dsString = function(dataset){
        let content = `window['${dataset.name}'] = ${pPrint(dataset.data)};`;
        return `<script id="${dataset.name}" type="text/babel">` + content + "</" + "script>"
      };
      let inlineData = _(datasets).map(dsString).reduce( (d, a) => `${d} \n ${a}` )                          

      let fileContent = `
        <!DOCTYPE html>
        <html>
        <head>
          <title>${title}</title>
          ${meta}
          ${cssImports}
          ${scriptImports}
        </head>
        <body>
          <div id="root"></div>
          ${inlineData}
          ${reactrCode}
        </body>
        </html>
      `

      return  fileContent
    };

    var saveToFile = function(){
      let currConf = config;

      let dataSets = _(currConf.datasets)
                      .map(function(ds){
                        let dsSettings = window[ds];
                        let name = dsSettings.dataset;
                        return [
                          {name: ds, data: dsSettings}, 
                          {name: name, data: datasets[name].q.getData()}
                        ]
                      })
                      .flatten()
                      .value();

      dataSets.push({name: 'config', data: config});


      let fileContent = {
        title:        currConf.title,
        stylesheets:  currConf.stylesheets,
        scripts:      currConf.scripts,
        datasets:     dataSets,
                       
      }
      promptForSave(generateFile(fileContent))
    };

    var generateStaticDoc = function(content){
      //defaults
      let {
        title       = 'reactr',
        meta        = `<meta charset="utf-8" />`,
        stylesheets = [],
        body        = ""
      } = content;

      let cssImports = _(stylesheets)
                          .map((ss) => `<link rel="stylesheet" href="${ss}">`)
                          .reduce((x, a) => `${x} \n        ${a}`);


      let fileContent = `
        <!DOCTYPE html>
        <html>
        <head>
          <title>${title}</title>
          ${meta}
          ${cssImports}
        </head>
        <body>
          ${body}
        </body>
        </html>
      `

      return  fileContent
    }

    var saveStaticDoc = function(){
      let currConf = config
      let body = ReactDOMServer.renderToString(
        React.createElement(window[currConf.docRoot], {data: datasets.data.data})
      )
      
      let fileContent = {
        title:        currConf.title,
        title:        currConf.title,
        stylesheets:  currConf.stylesheets,
        body:         body

      };

      promptForSave(generateStaticDoc(fileContent))
    };

    var init = function(){
      config = window["config"];
      _(config.datasets)
        .forEach(function(ds){
          let dsSettings = window[ds];
          datasets[dsSettings.dataset] = Container(dsSettings);
        });
    };

    init();

    ctrls = {
      saveToFile: saveToFile,
      saveStaticDoc: saveStaticDoc,
    }

    var run = function(){
      const rootElement = document.getElementById(config.elem)

      ReactDOM.render(
        <ReactrRoot datasets={datasets} ctrls={ctrls} />,
        rootElement
      );
    };

    return {
      run: run,
    }

  }

  var reactr = Reactr();

  reactr.run();

</script>




</body></html>
